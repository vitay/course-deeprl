{"title":"Keras tutorial","markdown":{"headingText":"Keras tutorial","containsRefs":false,"markdown":"\n\nThe goal of this tutorial is to very quickly present keras, the high-level API of tensorflow, as it has already been seen in the Neurocomputing exercises. We will train a small fully-connected network on MNIST and observe what happens when the inputs or outputs are correlated, by training successively on the 0 digits, then the 1, etc. \n\n## Keras\n\nThe first step is to install tensorflow. The easiest way is to use pip:\n    \n```bash\npip install tensorflow\n```\n\n`keras` is now available as a submodule of tensorflow (you can also install it as a separate package):\n\n```python\nimport tensorflow as tf\n```\n\nKeras provides a lot of ready-made layer types, activation functions, optimizers and so on. Do not hesitate to read its documentation on <https://keras.io>.\n\nThe most important object in keras is `Sequential`. It is a container where you sequentially add layers of neurons (fully-connected, convolutional, recurrent, etc) and other stuff. It represents your model, i.e. the neural network itself.\n\n```python\nmodel = tf.keras.models.Sequential()\n```\n\nYou can then `add()` layers to the model. A fully-connected layer is called `Dense` in keras. \n\nLet's create a MLP with 10 input neurons, two hidden layers with 100 hidden neurons each and 3 output neurons. \n\nThe input layer is represented by the `Input` layer:\n\n```python\nmodel.add(tf.keras.layers.Input((10,)))\n```\n\nThe first hidden layer can be added to the model with:\n\n```python\nmodel.add(tf.keras.layers.Dense(100, activation=\"relu\"))\n```\n\nThe layer has 100 neurons and uses the ReLU activation function. One could optionally define the activation function as an additional \"layer\", but it is usually not needed:\n\n```python\nmodel.add(tf.keras.layers.Dense(100))\nmodel.add(tf.keras.layers.Activation('relu'))\n```\n\nAdding more layers is straightforward:\n\n```python\nmodel.add(tf.keras.layers.Dense(100, activation=\"relu\"))\n```\n\nFinally, we can add the output layer. The activation function depends on the problem:\n\n* For regression problems, a linear activation function should be used when the targets can take any value (e.g. Q-values):\n\n```python\nmodel.add(tf.keras.layers.Dense(3, activation=\"linear\"))\n```\n\nIf the targets are bounded between 0 and 1, a logistic/sigmoid function can be used:\n\n```python\nmodel.add(tf.keras.layers.Dense(3, activation=\"sigmoid\"))\n```\n\n* For multi-class classification problems, a softmax activation function should be used:\n\n```python\nmodel.add(tf.keras.layers.Dense(3, activation=\"softmax\"))\n```\n\nThis defines fully the structure of your desired neural network.\n\n**Q:** Implement a neural network for classification with 10 input neurons, two hidden layers with 100 neurons each (using ReLU) and 3 output neurons.\n\n*Hint:* `print(model.summary())` gives you a summary of the architecture of your model. Note in particular the number of trainable parameters (weights and biases).\n\nThe next step is to choose an **optimizer** for the neural network, i.e. a variant of gradient descent that will be used to iteratively modify the parameters.\n\n`keras` provides an extensive list of optimizers: <https://keras.io/optimizers/>. The most useful in practice are:\n\n* `SGD`, the vanilla stochastic gradient descent.\n\n```python\noptimizer = tf.keras.optimizers.SGD(learning_rate=0.001, momentum=0.9, nesterov=True)\n```\n\n* `RMSprop`, using second moments:\n\n```python\noptimizer = tf.keras.optimizers.RMSprop(learning_rate=0.001)\n```\n\n* `Adam`:\n\n```python\noptimizer = tf.keras.optimizers.Adam(learning_rate=0.001)\n```\n\nChoosing a optimizer is a matter of taste and trial-and-error. In deep RL, a good choice is Adam: the default values for its other parameters are usually good, it converges well, so your only job is to find the right learning rate.\n\nFinally, the model must be **compiled** by defining:\n\n* A loss function. For multi-class classification, it should be `'categorical_crossentropy'`. For regression, it can be `'mse'`. See the list of built-in loss functions here: <https://keras.io/losses/> but know that you can also simply define your own.\n\n* The chosen optimizer.\n\n* The metrics, i.e. what you want tensorflow to print during training. By default it only prints the current value of the loss function. For classification tasks, it usually makes more sense to also print the `accuracy`.\n\n```python\nmodel.compile(\n    loss='categorical_crossentropy', \n    optimizer=optimizer,\n    metrics=['accuracy']\n)\n```\n\n**Q:** Compile the model for classification, using the Adam optimizer and a learning rate of 0.01.\n\nLet's now train the model on some dummy data. To show the power of deep neural networks, we will try to learn noise by heart.\n\nThe following cell creates an input tensor `X` with 1000 random vectors of 10 elements, with values sampled between -1 and 1. The targets (desired outputs) `t` are class indices (0, 1 or 2), also randomly selected.  \n\nHowever, neural networks expect **one-hot encoded vectors** for the target, i.e. (1, 0, 0), (0, 1, 0), (0, 0, 1) instead of 0, 1, 2. The method `tf.keras.utils.to_categorical` allows you to do that.\n\nLet's learn it. The `Sequential` model has a method called `fit()` where you simply pass the training data `(X, T)` and some other parameters, such as:\n\n* the batch size,\n* the total number of epochs,\n* the proportion of training examples to keep in order to compute the validation loss/accuracy (optional but recommmended).\n\n```python\n# Training\nhistory = tf.keras.callbacks.History()\n\nmodel.fit(\n    X, T,\n    batch_size=100, \n    epochs=50,\n    validation_split=0.1,\n    callbacks=[history]\n)\n```\n\n**Q:** Train the model on the data, using a batch size of 100 for 50 epochs. Explain why you obtained this result.\n\n**A:** The final training is 100%, the validation accuracy is 33% (may vary depending on initialization). The network has learned the training examples by heart, although they are totally random, but totally fails to generalize.\n\nThe main is reason is that we have only 1000 training examples, with a total number of free parameters (VC dimension) around 11500. By definition, the model can learn this training set perfectly, although it is totally random. Its VC dimension is however way to high to generalize anything. It is even worse here: as the data is random, there is nothing to generalize. A nice example to understand why NN overfit...\n\n## Training a MLP on MNIST\n\nLet's now try to learn something a bit more serious, the MNIST dataset. The following cell load the MNIST data (training set 60000 28x28 monochrome images, test set of 10000 images), normalizes it (values betwen 0 and 1 for each pixel), removes the mean image from the training set and transforms the targets to one-hot encoded vectors for the 10 classes. See the neurocomputing exercise for more details.\n\n**Q:** Create a fully connected neural network with 784 input neurons (one per pixel), 10 softmax output neurons and whatever you want in the middle, so that it can reach around 98% validation accuracy after **20 epochs**.\n\n* Put the network creation (including `compile()`) in a method `create_model()`, so that you can create a model multiple times.\n* Choose a good value for the learning rate.\n* Do not exagerate with the number of layers and neurons. Two or there hidden layers with 100 to 300 neurons are more than enough.\n* You will quickly observe that the network overfits: the training accuracy is higher than the validation accuracy. The training accuracy actually goes to 100% if your network is too big. In that case, feel free to add a dropout layer after each fully-connected layer:\n\n```python\nmodel.add(tf.keras.layers.Dropout(0.5))\n```\n\nAfter training, one should evaluate the model on the test set. `keras` provides an `evaluate()` method that computes the different metrics (in our case the loss) on the data:\n\n```python\nscore = model.evaluate(X_test, T_test)\n```\n\nAnother solution would be to `predict()` labels on the test set and manually compare them to the ground truth:\n\n```python\nY = model.predict(X_test)\nloss = - np.mean(T_test * np.log(Y))\npredicted_classes = np.argmax(Y, axis=1)\naccuracy = 1.0 - np.sum(predicted_classes != t_test)/t_test.shape[0]\n```\n\nAnother important thing to visualize after training is how the training and validation loss (or accuracy) evolved during training. The `fit()` method updates a `History` object which contains the history of your metrics (loss and accuracy) after each epoch of training. These are simple numpy arrays, accessible with:\n\n```python\nhistory.history['loss']\nhistory.history['val_loss']\nhistory.history['accuracy']\nhistory.history['val_accuracy']\n```\n\n**Q:** Compute the test loss and accuracy of your model. Plot the history of the training and validation loss/accuracy.\n\n## Correlated inputs\n\nNow that we have a basic NN working on MNIST, let's investigate why deep NN hate sequentially correlated inputs (which is the main justification for the experience replay memory in DQN). Is that really true, or is just some mathematical assumption that does not matter in practice?\n\nThe idea of this part is the following: we will train the same network as before for 20 epochs, but each epoch will train the network on all the 0s first, then all the 1s, etc. Each epoch will contain the same number of training examples as before, but the order of presentation will simply be different.\n\nTo get all examples of the training set which have the target 3 (for example), you just have to slice the matrices accordingly:\n\n```python\nX = X_train[t_train==3, :]\nT = T_train[t_train==3]\n```\n\n**Q:** Train the same network as before (but reinitialize it!) for 20 epochs, with each epoch sequentially iterating over the classes 0, 1, 2, 3, etc. Plot the loss and accurary during training. What do you observe?\n\n*Hint:* you will have two for loops to write: one over the epochs, one over the digits.\n\n```python\nfor e in range(20):\n    for c in range(10):\n        model.fit(...)\n```\n\nYou should only do one epoch for each call to `fit()`. Set `verbose=0` in `fit()` to avoid printing too much info.\n\n**A:** the training accuracy slowly increases (with some oscillations, some numbers are harder to learn than others), but the validation accuracy is suspiciously high right from the start...\n\n**Q:** Evaluate the model after training on the whole test set. What happens?\n\n**A:** horror! The test accuracy is now awful, although the training and validation accuracies were fine after 20 epochs.\n\n**Q:** To better understand what happened, compute the test accuracy of the network on each class of the test set individually: all the 0s of the test set, then all the 1s, etc. What happens? \n\n**A:** the last digits to be seen during training are the 9s: they have a good test accuracy. The 8s were seen not too long ago, they are also OK. But the other digits have been forgotten! The memory has been erased. This explains why you cannot train a deep network on-policy: the last episode would be remembered, but all the previous ones would be erased (catastrophic forgetting).\n\nA notable exception is for the 6s, which look like 9s, and the 0s, which look like 8s: they share features with the digits which are well recognized, so they perform OK.\n\n**Q:** Increase and decrease the learning rate of the optimizer. What do you observe? Is there a solution to this problem? \n\n**A:** Increasing the learning rate worsens the problem. Decreasing does help, but then learning is very slow. This is classical example of catastrophic forgetting: learning a new task erases the previous ones. There is no solution to this problem for now, apart from taking **i.i.d** samples in each minibatch.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../center_images.lua","quarto"],"number-sections":false,"toc":true,"html-math-method":"katex","output-file":"11-Keras-solution.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","bibliography":["../DeepLearning.bib","../ReinforcementLearning.bib"],"csl":"../frontiers.csl","theme":["cosmo","../custom.scss"],"page-layout":"full","number-depth":2,"smooth-scroll":true},"extensions":{"book":{"multiFile":true}}}}}