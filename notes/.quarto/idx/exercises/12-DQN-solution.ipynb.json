{"title":"DQN","markdown":{"headingText":"DQN","containsRefs":false,"markdown":"\n\nThe goal of this exercise is to implement DQN and to apply it to the cartpole balancing problem. \n\nLet's import eveything we need to run gym on Colab:\n\n\n## Cartpole balancing task\n\nWe are going to use the Cartpole balancing problem, which can be loaded with:\n\n```python\nenv = wrap_env(gym.make('CartPole-v0'))\n```\n\nStates have 4 continuous values (position and speed of the cart, angle and speed of the pole) and 2 discrete outputs (going left or right). The reward is +1 for each transition where the pole is still standing (angle of less than 30Â° with the vertical). The episode ends when the pole fails or after 200 steps. The maximal (undiscounted) return is therefore 200. Can DQN learn this?\n\nAs the problem is quite simple (4 state variables, 2 actions), DQN can run on a single CPU. However, we advise that you run the notebook on a GPU in Colab to avoid emptying the battery of your laptop too fast or making it too warm as training takes quite a long time.\n\nWe will forget from now on to display the cartpole on colab, it does not work well.\n\n## Creating the model\n\nThe first step is to create the value network using `keras`. We will not need anything fancy: a simple fully connected network with 4 input neurons, two hidden layers of 64 neurons each and 2 output neurons will do the trick. ReLU activation functions all along and the Adam optimizer.\n\n**Q:** Which loss function should we use? Think about which arguments have to passed to `model.compile()` and what activation function is required in the output layer.\n\nWe will need to create two identical networks: the trained network and the target network. You should therefore create a method that returns a compiled model, so it can be called two times. You should pass it the environment (so the network can know how many input and output neurons it needs) and the learning rate for the Adam optimizer.\n\n```python\ndef create_model(env, lr):\n    \n    model = Sequential()\n\n    # ...\n\n    return model\n```\n\n**Q:** Implement the method accordingly.\n\nLet's test this method by creating the trained and target networks.\n\n**Important:** every time you call `create_model`, a new neural network will be instantiated but the previous ones will not be deleted. During this exercise, you may have to create hundreds of networks because of the incremental implementation of DQN: all networks will stay instantiated in the RAM, and your computer/colab tab will freeze after a while. Before creating new networks, delete all existing ones with:\n\n```python\ntf.keras.backend.clear_session()\n```\n\n**Q:** Create the trained and target networks. The learning rate does not matter for now. Instantiate the Cartpole environment and print the output of both networks for the initial state (`state = env.reset()`). Are they the same?\n\n*Hint:* `model.predict()` expects an array of shape (N, 4), with N the number of examples. Here, we have only one example, so make sure to reshape `state` so it has the shape (1, 4) (otherwise tf will complain).\n\nThe target network has the same structure as the trained network, but not the same weights, as they are randomly initialized. We want the target network $\\theta'$ to have exactly the same weights as the trained weights $\\theta$. You can obtain the weights of a network with:\n\n```python\nw = model.get_weights()\n```\n\nand set weights using:\n\n```python\nmodel.set_weights(w)\n```\n\n**Q:** Transfer the weights of the trained model to the target model. Compare their predictions for the current state.\n\n## Experience replay memory\n\nThe second thing that we need is the experience replay memory (or replay buffer). We need a container like a python list where we append (s, a, r, s', done) transitions (as in Q-learning), but with a maximal capacity: when there are already $C$ transitions in the list, one should stop appending to the list, but rather start writing at the beginning of the list.\n\nThis would not be very hard to write, but it would take a lot of time and the risk is high to have hard-to-notice bugs. \n\nHere is a basic implementation of the replay buffer using **double-ended queues** (deque). A deque is list with a maximum capacity. If the deque is full, it starts writing again at the beginnning. Exactly what we need. This implementation uses one deque per element in (s, a, r, s', done), but one could also append the whole transition to a single deque.\n\n**Q:** Read the code of the ReplayBuffer and understand what it does.\n\n**Q:** Run a random agent on Cartpole for a few episodes and append each transition to a replay buffer with small capacity (e.g. 100) and sample batches from time to time. Check that everything makes sense.\n\n## DQN agent\n\nHere starts the fun part. There are a lot of things to do here, but you will now whether it works or not only when everything has been (correctly) implemented. So here is a lot of text to read carefully, and then you are on your own.\n\nReminder from the lecture:\n\n* Initialize value network $Q_{\\theta}$ and target network $Q_{\\theta'}$.\n\n* Initialize experience replay memory $\\mathcal{D}$ of maximal size $N$.\n\n* for $t \\in [0, T_\\text{total}]$:\n\n    * Select an action $a_t$ based on $Q_\\theta(s_t, a)$, observe $s_{t+1}$ and $r_{t+1}$.\n\n    * Store $(s_t, a_t, r_{t+1}, s_{t+1})$ in the experience replay memory.\n\n    * Every $T_\\text{train}$ steps:\n\n        * Sample a minibatch $\\mathcal{D}_s$ randomly from $\\mathcal{D}$.\n\n        * For each transition $(s_k, a_k, r_k, s'_k)$ in the minibatch:\n\n            * Compute the target value $t_k = r_k + \\gamma \\, \\max_{a'} Q_{\\theta'}(s'_k, a')$ using the target network.\n\n        * Update the value network $Q_{\\theta}$ on $\\mathcal{D}_s$ to minimize:\n\n        $$\\mathcal{L}(\\theta) = \\mathbb{E}_{\\mathcal{D}_s}[(t_k - Q_\\theta(s_k, a_k))^2]$$\n\n    * Every $T_\\text{target}$ steps:\n\n        * Update target network: $\\theta' \\leftarrow \\theta$.\n\nHere is the skeleton of the `DQNAgent` class that you have to write:\n\n```python\nclass DQNAgent:\n    \n    def __init__(self, env, create_model, some_parameters):\n        \n        self.env = env\n        \n        # TODO: copy the parameters\n\n        # TODO: Create the trained and target networks, copy the weights.\n\n        # TODO: Create an instance of the replay memory\n        \n    def act(self, state):\n\n        # TODO: Select an action using epsilon-greedy on the output of the trained model\n\n        return action\n    \n    def update(self, batch):\n        \n        # TODO: train the model using the batch of transitions\n        \n        return loss # mse on the batch\n\n    def train(self, nb_episodes):\n\n        returns = []\n        losses = []\n\n        # TODO: Train the network for the given number of episodes\n\n        return returns, losses\n\n    def test(self):\n\n        # TODO: one episode with epsilon temporarily set to 0\n\n        return nb_steps # Should be 200 after learning\n```\n\nWith this structure, it will be very simple to actually train the DQN on Cartpole:\n\n```python\n# Create the environment\nenv = gym.make('CartPole-v0')\n\n# Create the agent\nagent = DQNAgent(env, create_model, other_parameters)\n\n# Train the agent\nreturns, losses = agent.train(nb_episodes)\n\n# Plot the returns\nplt.figure(figsize=(10, 6))\nplt.plot(returns)\nplt.plot(running_mean(returns, 10))\nplt.xlabel(\"Episodes\")\nplt.ylabel(\"Returns\")\n\n# Plot the losses\nplt.figure(figsize=(10, 6))\nplt.plot(losses)\nplt.xlabel(\"Episodes\")\nplt.ylabel(\"Training loss\")\n\nplt.show()\n\n# Test the network\nnb_steps = agent.test()\nprint(\"Number of steps:\", nb_steps)\n```\n\nSo you \"just\" have to fill the holes.\n\n\n\n### 1 - `__init__()`: Initializing the agent\n\nIn this method, you should first copy the value of the parameters as attributes: learning rate, epsilon, gamma and so on.\n\nSuggested values: gamma = 0.99, learning_rate = 0.001 \n\nThe second thing to do is to create the trained and target networks (with the same weights) and save them as attributes (the other methods will use them). Do not forget to clear the keras session first, otherwise the RAM will be quickly filled.\n\nThe third thing is to create an instance of the ERM. Use a buffer limit of 5000 transitions (should be passed as a parameter). \n\nDo not hesitate to add other stuff as you implementing the other methods (e.g. counters).\n\n### 2 - `act()`: action selection\n\nWe will use a simple $\\epsilon$-greedy method for the action selection, as in the previous exercises. \n\nThe only difference is that we have to use the trained model to get the greedy action, using `trained_model.predict()`. This will return the Q-value of the two actions left and right. Use `argmax()` to return the greedy action (with probability 1 - $\\epsilon$). `env.action_space.sample()` should be used for the exploration (do not use the Q-network in that case, it is slow!).\n\n$\\epsilon$ will be scheduled with an initial value of 1.0 and an exponential decay rate of 0.0005 after each action. It is always better to keep a little exploration, even if $\\epsilon$ has decayed to 0. Keep a minimal value of 0.05 for epsilon. \n\n**Q:** Once this has been implemented, run your very slow random agent for 100 episodes to check everything works correctly.\n\n### 3 - `train()`: training loop\n\nThis method will be very similar to the Q-learning agent that you implemented previously. Do not hesitate to copy and paste.\n\nHere is the parts of the DQN algorithm that should be implemented:\n\n* for $t \\in [0, T_\\text{total}]$:\n\n    * Select an action $a_t$ based on $Q_\\theta(s_t, a)$, observe $s_{t+1}$ and $r_{t+1}$.\n\n    * Store $(s_t, a_t, r_{t+1}, s_{t+1})$ in the experience replay memory.\n\n    * Every $T_\\text{train}$ steps:\n\n        * Sample a minibatch $\\mathcal{D}_s$ randomly from $\\mathcal{D}$.\n\n        * Update the trained network using $\\mathcal{D}_s$.\n\n    * Every $T_\\text{target}$ steps:\n\n        * Update target network: $\\theta' \\leftarrow \\theta$.\n\nThe main difference with Q-learning is that `update()` will be called only every `T_train = 4` steps: the number of updates to the trained network will be 4 times smaller that the number of steps made in the environment. Beware that if the ERM does not have enough transitions yet (less than the batch size), you should not call `update()`.\n\nUpdating the target network (copying the weights of the trained network) should happen every 100 steps. Pass these parameters to the constructor of the agent. \n\nThe batch size can be set to 32.\n\n### 4 - `update()`: training the value network\n\nUsing the provided minibatch, one should implement the following part of the DQN algorithm:\n\n* For each transition $(s_k, a_k, r_k, s'_k)$ in the minibatch:\n\n    * Compute the target value $t_k = r_k + \\gamma \\, \\max_{a'} Q_{\\theta'}(s'_k, a')$ using the target network.\n\n* Update the value network $Q_{\\theta}$ on $\\mathcal{D}_s$ to minimize:\n\n    $$\\mathcal{L}(\\theta) = \\mathbb{E}_{\\mathcal{D}_s}[(t_k - Q_\\theta(s_k, a_k))^2]$$\n\nSo we just need to define the targets for each transition in the minibatch, and call `model.fit()` on the trained network to minimize the mse between the current predictions $Q_\\theta(s_k, a_k)$ and the target.\n\nBut we have a problem: the network has two outputs for the actions left and right, but we have only one target for the action that was executed. We cannot compute the mse between a vector with 2 elements and a single value... They must have the same size.\n\nAs we want only the train the output neuron corresponding to the action $a_k$, we are going to:\n\n1. Use the trained network to predict the Q-value of both actions $[Q_\\theta(s_k, 0), Q_\\theta(s_k, 1)]$.\n2. Replace one of the values with the target, for example $[Q_\\theta(s_k, 0), t_k]$ if the second action was chosen.\n3. Minimize the mse between $[Q_\\theta(s_k, 0), Q_\\theta(s_k, 1)]$ and $[Q_\\theta(s_k, 0), t_k]$.\n\nThat way, the first output neuron has a squared error of 0, so it won't learn anything. Only the second output neuron will have a non-zero mse and learn.\n\nThere are more efficient ways to do this (using masks), but this will do the trick, the drawback being that we have to make a forward pass on the minibatch before calling `fit()`.\n\nThe rest is pretty much the same as for your Q-learning agent. Do not forget that actions leading to a terminal state should only use the reward as a target, not the complete Bellman target $r + \\gamma \\max Q$.\n\n*Hint:* as we sample a minibatch of 32 transitions, it is faster to call:\n\n```python\nQ_values = np.array(training_model.predict_on_batch(states))\n```\n\nthan:\n\n```python\nQ_values = training_model.predict(states)\n```\n\nfor reasons internal to tensorflow. Note that with tf2, you need to cast the result to numpy arrays as eager mode is now the default.\n\nThe method should return the training loss, which is contained in the `History` object returned by `model.fit()`. `model.fit()` should be called for one epoch only, a batch size of 32, and `verbose` set to 0. \n\n### 5 - `test()`\n\nThis method should run one episode with epsilon set to 0, without learning. The number of steps should be returned (do not bother discounting with gamma, the goal is to be up for 200 steps). \n\n**Q:** Let's go! Run the agent for 100 episodes and observe how fast it manages to keep the pole up for 200 steps. \n\nBeware that running the same network twice can lead to very different results. In particular, policy collapse (the network was almost perfect, but suddenly crashes and becomes random) can happen. Just be patient. \n\n**Q:** How does the loss evolve? Does it make sense?\n\n**A:** The Q-values are non-stationary: the initial Q-values are very small (the agent fails almost immediately), while they are around 40 after training (200 steps, but discounted with gamma). The mse increases with the magnitude of the Q-values, so the loss is a poor indicator of the convergence of the network. \n\n## Reward scaling\n\n**Q:** Do a custom test trial after training (i.e. do not call test(), but copy and adapt its code) and plot the Q-value of the selected action at each time step. Do you think it is a good output for the network? Could it explain why learning is so slow?\n\n**A:** The predicted Q-values at the beginning of learning are close to 0, as the weights are randomly initialized. They must grow to around 40, which takes a lot of time. If the target Q-values were around 1, learning might be much faster.\n\n**Q:** Implement **reward scaling** by dividing the received rewards by a fixed factor of 100 when computing the Bellman targets. That way, the final Q-values will be around 1, what may be much easier  to learned.\n\n*Tip:* in order to avoid a huge copy and paste, you can inherit from your DQNAgent and ony reimplement the desired function:\n\n```python\nclass ScaledDQNAgent (DQNAgent):\n    def update(self, batch):\n        # Change the content of this function only\n```\n\nYou should reduce a bit the learning rate (e.g. 0.001) as the magnitude of the targets has changed. \n\n**Q:** Depending on the time left and your motivation, vary the different parameters to understand their influence: learning rate, target update frequency, training update frequency, epsilon decay, gamma, etc. Change the size of the network. If you find better hyperparameters than what is proposed, please report them for next year!\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../center_images.lua","quarto"],"number-sections":false,"toc":true,"html-math-method":"katex","output-file":"12-DQN-solution.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","bibliography":["../DeepLearning.bib","../ReinforcementLearning.bib"],"csl":"../frontiers.csl","theme":["cosmo","../custom.scss"],"page-layout":"full","number-depth":2,"smooth-scroll":true},"extensions":{"book":{"multiFile":true}}}}}