{"title":"Numpy and Matplotlib","markdown":{"headingText":"Numpy and Matplotlib","containsRefs":false,"markdown":"\n\n## Numpy numerical library\n\nNumPy is a linear algebra library in Python, with computationally expensive methods written in FORTRAN for speed. \n\n* The reference manual is at <https://numpy.org/doc/stable/>. \n* A nice tutorial can be found at <https://numpy.org/doc/stable/user/quickstart.html>\n* or: <https://cs231n.github.io/python-numpy-tutorial/>\n* If you already know Matlab, a comparison is at <https://numpy.org/doc/stable/user/numpy-for-matlab-users.html>\n\n### Importing libraries\n\nTo import a library in Python, you only need to use the keyword `import` at the beginning of your script / notebook (or more exactly, before you use it).\n\n```python\nimport numpy\n```\n\nThink of it as the equivalent of `#include <numpy.h>` in C/C++ (if you know Java, you will not be shocked). You can then use the functions and objects provided by the library using the namespace of the library:\n\n```python\nx = numpy.array([1, 2, 3])\n```\n\nIf you do not want to type `numpy.` everytime, and if you are not afraid that numpy redefines any important function, you can also simply import every definition declared by the library in your current namespace with:\n\n```python\nfrom numpy import *\n```\n\nand use the objects directly:\n\n```python\nx = array([1, 2, 3])\n```\n\nHowever, it is good practice to give an alias to the library when its name is too long (numpy is still okay, but think of matplotlib...):\n\n```python\nimport numpy as np \n```\n\nYou can then use the objects like this:\n\n```python\nx = np.array([1, 2, 3])\n```\n\nRemember that you can get help on any NumPy function:\n\n```python\nhelp(np.array)\nhelp(np.ndarray.transpose)\n```\n\n### Vectors and matrices\n\nThe basic object in NumPy is an **array** with d-dimensions (1D = vector, 2D = matrix, 3D or more = tensor). They can store either integers or floats, using various precisions.\n\nIn order to create a vector of three floats, you simply have to build an `array()` object by providing a list of floats as input:\n\n```python\nA = np.array( [ 1., 2., 3.] )\n```\n\nMatrices should be initialized with a list of lists.  For a 3x4 matrix of 8 bits unsigned integers, it is:\n\n```python\nB = np.array( [ \n    [ 1, 2, 3, 4],\n    [ 5, 6, 7, 8],\n    [ 4, 3, 2, 1] \n  ] , dtype=np.uint8)\n```\n\nMost of the time, you won't care about the type (the default floating-point precision is what you want for machine learning), but if you need it, you can always specify it with the parameter `dtype={int32, uint16, float64, ...}`. Note that even if you pass integers to the array (`np.array( [ 1, 2, 3] )`), they will be converted to floats by default.\n\nThe following attributes of an array can be accessed:\n\n- `A.shape` : returns the shape of the vector `(n,)` or matrix `(m, n)`.\n\n- `A.size` : returns the total number of elements in the array.\n\n- `A.ndim` : returns the number of dimensions of the array (vector: 1, matrix:2).\n\n- `A.dtype.name` : returns the type of data stored in the array (int32, uint16, float64...).\n\n**Q:** Define the two arrays $A$ and $B$ from above and print those attributes. Modify the arrays (number of elements, type) and observe how they change. \n\n*Hint:* you can print an array just like any other Python object.\n\nInternally, the values are stored sequentially as a vector, even if your array has more than one dimension. The apparent shape is just used for mathematical operations. You can **reshape** a matrix very easily with the `reshape()` method:\n\n```python\nB = np.array( [ \n    [ 1, 2, 3, 4],\n    [ 5, 6, 7, 8],\n    [ 4, 3, 2, 1] \n]) # B has 3 rows, 4 columns\n\nC = B.reshape((6, 2)) # C has 6 rows, 2 columns\n```\n\nThe only thing to respect is that the total number of elements must be the same. Beware also of the order in which the elements will be put.\n\n**Q:** Create a vector with 8 elements and reshape it into a 2x4 matrix.\n\n### Initialization of an array\n\nProviding a list of values to `array()` would be tedious for large arrays. Numpy offers constructors that allow to construct simply most vectors or matrices.\n\n`np.zeros(shape)` creates an array of shape `shape` filled with zeros. Note: if you give a single integer for the shape, it will be interpreted as a vector of shape `(d,)`. \n\n`np.ones(shape)` creates an array of shape `shape` filled with ones. \n\n`np.full(shape, val)` creates an array of shape `shape` filled with `val`. \n\n`np.eye(n)` creates a diagonal matrix of shape `(n, n)`.\n\n`np.arange(a, b)` creates a vector of integers whose value linearly increase from `a` to `b` (excluded).\n\n`np.linspace(a, b, n)` creates a vector of `n` values evenly distributed between `a` and `b` (included).\n\n\n**Q:** Create and print:\n\n* a 2x3 matrix filled with zeros.\n* a vector of 12 elements initialized to 3.14.\n* a vector of 11 elements whose value linearly increases from 0.0 to 10.0.\n* a vector of 11 elements whose value linearly increases from 10 to 20.\n\n### Random distributions\n\nIn many cases, it is useful to initialize a vector or matrix with random values. **Random number generators** (rng) allows to draw numbers from any probability distribution (uniform, normal, etc.) using pseudo-random methods. \n\nIn numpy versions before 1.16, the `numpy.random` module had direct methods allowing to initialize arrays:\n\n```python\nA = np.random.uniform(-1.0, 1.0, (10, 10)) # a 10x10 matrix with values uniformly taken between -1 and 1\n```\n\nSince numpy 1.16, this method has been deprecated in favor of a more explicit initialization of the underlying rng:\n\n```python\nrng = np.random.default_rng()\nA = rng.uniform(-1.0, 1.0, (10, 10))\n```\n\nThe advantages of this new method (reproducibility, parallel seeds) will not matter for these exercises, but let's take good habits already.\n\nThe generator has many built-in methods, covering virtually any useful probability distribution. Read the documentation of the random generator:\n\n<https://numpy.org/doc/stable/reference/random/generator.html>\n\n**Q:** Create:\n\n* A vector of 20 elements following a normal distribution with mean 2.0 and standard devation 3.0.\n* A 10x10 matrix whose elements come from the exponential distribution with $\\beta = 2$.\n* A vector of 10 integers randomly chosen between 1 and 100 (hint: involves `arange` and `rng.choice`).\n\n### Manipulation of matrices: indices, slices\n\nTo access a particular element of a matrix, you can use the usual Python list style (the first element has a rank of 0), once per dimension:\n\n```python\nA = np.array(\n    [ \n        [ 1,  2,  3,  4],\n        [ 5,  6,  7,  8],\n        [ 9, 10, 11, 12]\n    ]\n)\n\nx = A[0, 2] # The element on the first row and third column\n```\n\nFor matrices, the first index represents the rows, the second the columns. [0, 2] represents the element at the first row, third column.\n\n**Q:** Define this matrix and replace the element `12` by a zero using indices:\n\nIt is possible to access complete row or columns of a matrix using **slices**. The `:` symbol is a shortcut for \"everything\":\n\n```python\nb = A[:, 2] # third column\nc = A[0, :] # first row\n```\n\n**Q:** Set the fourth column of A to 1.\n\nAs for python lists, you can specify a range `start:stop` to get only a subset of a row/column (beware, stop is excluded):\n\n```python\nd = A[0, 1:3] # second and third elements of the first row\ne = A[1, :2] # first and second elements of the second row\n```\n\nYou can use boolean arrays to retrieve indices:\n\n```python\nA = np.array( \n    [ [ -2,  2,  1, -4],\n      [  3, -1, -5, -3] ])\n\nnegatives = A < 0 # Boolean array where each element is True when the condition is met.\nA[negatives] = 0 # All negative elements of A (where the boolean matrix is True) will be set to 0\n```\n\nA simpler way to write it is:\n\n```python\nA[A < 0] = 0\n```\n\n**Q:** print A, negatives and A again after the assignment:\n\n### Basic linear algebra \n\nLet's first define some matrices:\n\n#### Transpose a matrix \n\nA matrix can be transposed with the `transpose()` method or the `.T` shortcut:\n\n```python\nD = A.transpose() \nE = A.T # equivalent\n```\n\n**Q:** Try it:\n\n`transpose()` does not change `A`, it only returns a transposed copy. To transpose `A` definitely, you have to use the assigment `A = A.T`\n\n#### Multiply two matrices \n\nThere are two manners to multiply matrices:\n\n- element-wise: Two arrays of **exactly** the same shape can be multiplied *element-wise* by using the `*` operator:\n\n```python\nD = A * B\n```\n\n- algebrically: To perform a **matrix multiplication**, you have to use the `dot()` method. Beware: the dimensions must match! `(m, n) * (n, p) = (m, p)`\n\n```python\nE = np.dot(A,  B)\n```\n\n**Q:** Use the matrices `A` and `B` previously defined and multiply them element-wise and algebrically. You may have to transpose one of them.\n\n#### Multiplying a matrix with a vector\n\n`*` and `np.dot` also apply on matrix-vector multiplications $\\mathbf{y} = A \\times \\mathbf{x}$ or vector-vector multiplications.\n\n**Q:** Define a vector $\\mathbf{x}$ with four elements and multiply it with the matrix $A$ using `*` and `np.dot`. What do you obtain? Try the same by multiplying the vector $\\mathbf{x}$ and itself.\n\n**A:** the element-wise multiplies each column of the matrix by the corresponding element of the vector. `np.dot` works as expected. The same happens for vector-vector multiplications: element-wise for `*`, dot-product for `np.dot` (hence the name of the method).\n\n#### Inverting a matrix\n\nInverting a Matrix (when possible) can be done using the `inv()` method whitch is defined in the `linalg` submodule of NumPy.\n\n```python\ninv_C = np.linalg.inv(C)\n```\n\n**Q:**\n\n1. Invert `C` and print the result.\n2. Multiply `C` with its inverse and print the result. What do observe? Why is Numpy called a *numerical computation* library?\n\n**A:** Some elements which should be 0 have a very small value. This is due to numerical precision issues. Numpy does not make symbolic computations like Mathematica or sympy, it deals with numbers up to a certain precision.\n\n### Summing elements \n\nOne can sum the elements of a matrix globally, row-wise or column-wise:\n\n```python\n# Globally\nS1 = np.sum(A)\n\n# Per column\nS2 = np.sum(A, axis=0) \n\n# Per row\nS3 = np.sum(A, axis=1) \n```\n\n**Q:** Try them:\n\nYou also have access to the minimum (`np.min()`), maximum (`np.max()`), mean (`np.mean()`) of an array, also per row/column. \n\n**Q:** Try them out:\n\n### Mathematical operations \n\nYou can apply any usual mathematical operations (cos, sin, exp, etc...) on each element of a matrix (element-wise):\n\n```python\nD = np.exp(A)\nE = np.cos(A)\nF = np.log(A)\nG = (A+3) * np.cos(A-2)\n```\n\n**Q:** Try it.\n\n## Matplotlib\n\nMatplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms.\n\n* Reference: <http://matplotlib.org>\n* Tutorial by N. Rougier: <http://www.labri.fr/perso/nrougier/teaching/matplotlib>\n\nThis is the default historical visualization library in Python, which anybody should know, but not the nicest. If you are interested in having better visualizations, have a look at:\n\n* `seaborn` <https://seaborn.pydata.org/>\n* `ggplot2` <https://ggplot2.tidyverse.org/>\n* `bokeh` <https://docs.bokeh.org/>\n* `plotly` <https://plotly.com/python/>\n\nWe will nevertheless stick to matplotlib in these exercises.\n\nThe `pyplot` module is the most famous, as it has a similar interface to Matlab. It is customary to use the `plt` namescape for it:\n\n### `plt.plot()`\n\nThe `plt.plot()` command allows to make simple line drawings:\n\n```python\nx = np.linspace(0., 10., 100)\ny = x**2 + 1.\n\nplt.figure()\nplt.plot(x, y)\nplt.show()\n```\n\n`plot()` takes two vectors `x` and `y` as inputs (they must have the same size) and plots them against each other. It is standard to define the x-axis with `np.linspace()` if you just want to plot a function. 100 points is usually a good choice, but you can experiments with less points.\n\nThe call to `plt.show()` is obligatory at the end to display the window when using a script (very common mistake to forget it!). It is not needed in Jupyter notebooks as it is implicitly called, but let's take the habit anyway. \n\nThe call to `plt.figure()` is also optional, as a new figure is created when you call `plt.plot()` for the first time.\n\n**Q:** Create a third vector `z` (e.g. `z = -x**2 + 2`) and plot it against `x` right after `y` (i.e. between `plt.plot(x, y)` and `plt.show()`). What happens?\n\n**Q:** Now call `plt.figure()` again between the two plots. What happens?\n\nBy default, the plot is quite empty. This is fine when experimenting in a notebook, but not when incorporating the figures in your thesis. You can make a plot look better by adding a title, labels on the axes, etc. \n\n```python\nplt.title('My title')\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n```\n\n**Q:** Make the previous plots nicer by adding legends and axes.\n\n*Hint:* if you know LateX equations, you can insert simple formulas in the title or axes by using two dollar signs `$$`.\n\nIf you make multiple plots on the same figure by calling `plt.plot()` multiple times, you can add a label to each plot to create a legend with `plt.legend()`:\n\n```python\nplt.plot(x, y, label='y')\nplt.plot(x, z, label='z')\nplt.legend()\n```\n\nAnother advantage of declaring a figure is that you can modify its size (which is very small in a notebook by default) with the `figsize` argument in inches:\n\n```python\nplt.figure(figsize=(16, 10))\n```\n\n**Q:** Experiment with figure sizes.\n\n### Side-by-side plots\n\nTo make separate plots in the same figure, you can use `plt.subplot(abc)`.\n\nThe function takes three digits a, b, c as input (e.g. 221 or 122) where:\n\n- a is the number of rows.\n- b is the number of columns.\n- c is the index (starting at 1) of the current subplot.\n\nHere is a dummy example of a 2x2 grid of plots:\n\n```python\nplt.subplot(221)\nplt.plot(x, y)\n\nplt.subplot(222)\nplt.plot(x, z)\n\nplt.subplot(223)\nplt.plot(y, x)\n\nplt.subplot(224)\nplt.plot(z, x)\n```\n\n**Q:** Try it.\n\n### `plt.imshow`\n\nMatrices can be displayed using `plt.imshow()`. You can choose the color code with the `cmap` argument (e.g. `gray` or `hot`).\n\n```python\nplt.imshow(A, cmap=plt.cm.hot, interpolation='nearest')\nplt.colorbar()\n```\n\n`plt.colorbar()` allows to show a vertical bar indicating the color code. \n\nThe interpolation method can also be selected for small matrices (`'nearest` by default, but you can choose `interpolation=\"bicubic\"` for a smoother display).\n\n(0, 0) is at the top-left of the image, the first axis is vertical. Change it with the `origin` parameter.\n\n**Q:** Create a 10x10 matrix (e.g. randomly) and plot it. Try different color maps (<https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html> and interpolation methods.\n\n### `plt.scatter`\n\nIf you want to display dots instead of of lines or pixels, `plt.scatter` takes two vectors of same size and plots them against each other:\n\n```python\nplt.scatter(x, y)\n```\n\n**Q:** Create two vectors with 100 elements and make a scatter plot.\n\n### `plt.hist()`\n\nHistograms can be useful to visualize the distribution of some data. If `z` is a vector of values, the histogram is simply:\n\n```python\nplt.hist(z, bins=20)\n```\n\nThe number of bins is 10 by default, but you can of course change it.\n\n**Q:** Draw 1000 values from a normal distribution of your choice and make an histogram.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../center_images.lua","quarto"],"number-sections":false,"toc":true,"html-math-method":"katex","output-file":"2-Numpy-solution.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","bibliography":["../DeepLearning.bib","../ReinforcementLearning.bib"],"csl":"../frontiers.csl","theme":["cosmo","../custom.scss"],"page-layout":"full","number-depth":2,"smooth-scroll":true},"extensions":{"book":{"multiFile":true}}}}}